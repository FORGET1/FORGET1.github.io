<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解JavaScript作用域]]></title>
    <url>%2F2017%2F06%2F14%2F%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是作用域作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。 为什么需要作用域？最小访问原则那么限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。 JavaScript中的作用域在JavaScript中有两种作用域 全局作用域 局部作用域 当变量定义在一个函数中时，变量就在局部作用域中，而定义在函数之外的变量则从属于全局作用域。每个函数在调用的时候会创建一个新的作用域。 全局作用域当你在文档中（document）编写JavaScript时，你就已经在全局作用域中了。JavaScript在文档中（document）只有一个全局作用域。定义在函数之外的变量会被保存在全局作用域中。 12// the scope is by default globalvar name = &apos;Hammad&apos;; 全局作用域里的变量能够在其他作用域中被访问和修改。 123456789var name = &apos;Hammad&apos;;console.log(name); //logs &apos;Hammad&apos;function logName() &#123; console.log(name); //&apos;name&apos; is accessible here and everywhere else&#125;logName(); //logs &apos;Hammad&apos; 局部作用域定义在函数中的变量就在局部作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。 12345678910111213//Global Scopefunction someFunction() &#123; //Local Scope ##1 function someOtherFunction() &#123; //Local Scope ##2 &#125;&#125;//Global Scopefunction anotherFunction() &#123; //Local Scope ##3&#125;//Global Scope 块语句块级声明包括if和switch，以及for和while循环，和函数不同，它们不会创建新的作用域。在块级声明中定义的变量从属于该块所在的作用域。 123456if(true) &#123; //this &apos;if&apos; conditional block doesn&apos;t create a new scope var name = &apos;Hammad&apos;;&#125;console.log(name); //logs &apos;Hammad&apos; ECMAScript6引入了let和const关键字。这些关键字可以代替var。 1234var name = &apos;Hammad&apos;;let likes = &apos;Coding&apos;;const skills = &apos;Javascript and PHP&apos;; 和var关键字不同，let和const关键字支持在块级声明中创建使用局部作用域。 1234567891011121314if(true) &#123; //this &apos;if&apos; conditional block doesn&apos;t create a scope //name is in the global scope because of the &apos;var&apos; keyword var name = &apos;Hammad&apos;; //likes is in the local scope because of the &apos;let&apos; keyword let likes = &apos;Coding&apos;; //skills is in the local scope because of the &apos;const&apos; keyword const skills = &apos;Javascript and PHP&apos;;&#125;console.log(name); //logs &apos;Hammad&apos;console.log(likes); //Uncaught ReferenceError: likes is not definedconsole.log(skills); //Uncaught ReferenceError: skills is not defined 一个应用中全局作用域的生存周期与该应用相同。局部作用域只在该函数调用执行期间存在。 上下文很多开发者经常弄混作用域和上下文，似乎两者是一个概念。但并非如此。作用域是我们上面讲到的那些，而上下文通常涉及你代码某些特殊部分中的this值。作用域指的是变量的可见性。而上下文指的是在相同的作用域中的this的值。我们当然也可以使用函数方法改变上下文，这个之后我们再讨论。在全局作用域中，上下文总是Window对象。 123456789//logs:Window &#123;speechSynthesis:SpeechSynthesis,cache:CacheStorage,localStorage:Storage...&#125;console.log(this);function logFunction() &#123; console.log(this);&#125;//logs:Window &#123;speechSynthesis:SpeechSynthesis,cache:CacheStorage,localStorage:Storage...&#125;//because logFunction() is not a property of an objectlogFunction(); 如果作用域定义在一个对象方法中，上下文就是这个方法所在的那个对象。 1234567class User &#123; logName() &#123; console.log(this); &#125;&#125;(new User).logName(); //logs User&#123;&#125;]]></content>
      <categories>
        <category>Web開発</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
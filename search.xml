<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web前端知识体系精要]]></title>
    <url>%2F2017%2F06%2F25%2FWeb%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%B2%BE%E8%A6%81%2F</url>
    <content type="text"><![CDATA[Web前端技术由html、css和javascript三大部分构成，是一个庞大而复杂的知识体系，其复杂程度不低于任何一门后端语言。而我们在学习它的时候往往是先从某一个点切入，然后不断的接触和学习新的知识点，因此对于初学者很难理清整个体系的脉络结构。本文将对Web前端知识体系进行简单的梳理，对应每个知识点点到为止，不作详细介绍，如有遗漏或不正确的地方，希望共勉。 JAVASCRIPT篇基础语法Javascript基础语法包括：变量定义、数据类型、循环、选择、内置对象等。 数据类型有string,number,boolean,undefined,object等。其中string,number和boolean是基础类型，null和undefined是JS中的两个特殊类型，object是引用类型。 Javascript可以通过typeof来判断基础数据类型，但不能够准确判断引用类型，因此需要用到另外一个方法，那就是Object的toString，关于数据类型及其判断可以参考以下博客：js基本数据类型和typeof和js基本数据类型和typeof JS常用的内置对象有Date、Array、JSON，RegExp等。一般来讲，Date和Array用的最频繁，JSON可以对对象和数组进行序列化和反序列化，还有一个作用就是实现对象的深拷贝。 RegExp即正则表达式，是处理字符串的利器。关于数据类型和正则表达式的介绍可以参考博客：ES5对数组增强的9个API和JS正则表达式精简 函数原型链Javascript虽然没有继承概念，但Javascript在函数Function对象中建立了原型对象prototype，并以Function对象为主线，从上至下，在内部构建了一条原型链。 简单来说就是建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型链上去找，知道Object对象为止，如果都没有找到该属性才会返回undefined。 因此我们经常会利用函数的原型机制来实现JS继承。关于函数原型链可参考博客：JS原型对象和原型链 函数作用域函数作用域就是变量在声明它们的函数体以及这个函数嵌套的任意函数体内都是有定义的。在JS中没有块级作用域，只有函数作用域，因此JS中还存在着另外一种怪异现象，那就是变量提升。关于作用域的介绍请参考博客：函数的作用域和作用域链 函数指针thisthis存在于函数中，它指向的时该函数在运行时被调用的那个对象。在实际项目中，遇到的this的坑比较多，因此需要对this作深入的理解。 Function对象还提供了call、apply和bind等方法来改变函数的this指向，其中call和apply主动执行函数，bind一般在事件回调中使用，而call和apply的区别只是参数的传递方式不同。关于call、apply和bind的用法请参考博客：详解JS的call、apply和bind 构造函数newJS中的函数既可以时构造函数又可以当做普通函数来调用，当使用new来创建对象时，对应的函数就是构造函数，通过对象来调用时就是普通函数。 普通函数的创建有：显示声明、匿名定义、new Function()等三种形式。 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。new的详细介绍请参考博客：理解JS中new运算符 闭包闭包其实是一个主动执行的代码块，这个代码块的特殊之处是可以永久保存局部变量，但又不污染全局变量，可以形成一个独立的执行过程，因此我们经常用闭包来定义组件。关于闭包的介绍请参考：让你分分钟学会JS闭包]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>前端知识体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript作用域]]></title>
    <url>%2F2017%2F06%2F14%2F%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JavaScript有个特性称为作用域。尽管对于很多开发新手来说，作用域的概念不容易理解，我会尽可能地从最简单的角度向你解释它们。理解作用域能让你编写更优雅、错误更少的代码，并能帮助你实现强大的设计模式。 什么是作用域作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。 为什么需要作用域？最小访问原则那么限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。 JavaScript中的作用域在JavaScript中有两种作用域 全局作用域 局部作用域 当变量定义在一个函数中时，变量就在局部作用域中，而定义在函数之外的变量则从属于全局作用域。每个函数在调用的时候会创建一个新的作用域。 全局作用域当你在文档中（document）编写JavaScript时，你就已经在全局作用域中了。JavaScript在文档中（document）只有一个全局作用域。定义在函数之外的变量会被保存在全局作用域中。 12// the scope is by default globalvar name = 'Hammad'; 全局作用域里的变量能够在其他作用域中被访问和修改。 123456789var name = 'Hammad';console.log(name); //logs 'Hammad'function logName() &#123; console.log(name); //'name' is accessible here and everywhere else&#125;logName(); //logs 'Hammad' 局部作用域定义在函数中的变量就在局部作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。 12345678910111213//Global Scopefunction someFunction() &#123; //Local Scope ##1 function someOtherFunction() &#123; //Local Scope ##2 &#125;&#125;//Global Scopefunction anotherFunction() &#123; //Local Scope ##3&#125;//Global Scope 块语句块级声明包括if和switch，以及for和while循环，和函数不同，它们不会创建新的作用域。在块级声明中定义的变量从属于该块所在的作用域。 123456if(true) &#123; //this 'if' conditional block doesn't create a new scope var name = 'Hammad';&#125;console.log(name); //logs 'Hammad' ECMAScript6引入了let和const关键字。这些关键字可以代替var。 1234var name = 'Hammad';let likes = 'Coding';const skills = 'Javascript and PHP'; 和var关键字不同，let和const关键字支持在块级声明中创建使用局部作用域。 1234567891011121314if(true) &#123; //this 'if' conditional block doesn't create a scope //name is in the global scope because of the 'var' keyword var name = 'Hammad'; //likes is in the local scope because of the 'let' keyword let likes = 'Coding'; //skills is in the local scope because of the 'const' keyword const skills = 'Javascript and PHP';&#125;console.log(name); //logs 'Hammad'console.log(likes); //Uncaught ReferenceError: likes is not definedconsole.log(skills); //Uncaught ReferenceError: skills is not defined 一个应用中全局作用域的生存周期与该应用相同。局部作用域只在该函数调用执行期间存在。 上下文很多开发者经常弄混作用域和上下文，似乎两者是一个概念。但并非如此。作用域是我们上面讲到的那些，而上下文通常涉及你代码某些特殊部分中的this值。作用域指的是变量的可见性。而上下文指的是在相同的作用域中的this的值。我们当然也可以使用函数方法改变上下文，这个之后我们再讨论。在全局作用域中，上下文总是Window对象。 123456789//logs:Window &#123;speechSynthesis:SpeechSynthesis,cache:CacheStorage,localStorage:Storage...&#125;console.log(this);function logFunction() &#123; console.log(this);&#125;//logs:Window &#123;speechSynthesis:SpeechSynthesis,cache:CacheStorage,localStorage:Storage...&#125;//because logFunction() is not a property of an objectlogFunction(); 如果作用域定义在一个对象方法中，上下文就是这个方法所在的那个对象。 1234567class User &#123; logName() &#123; console.log(this); &#125;&#125;(new User).logName(); //logs User&#123;&#125; (new User).logName()是创建对象关联到变量并调用logName方法的一种简便形式。通过这种方式你并不需要创建一个新的变量。 你可能注意到一点，就是如果你使用new关键字调用函数时上下文的值会有差异。上下文会设置为被调用的函数的实例。考虑一下上面的这个例子，用new关键字调用的函数。 12345function logFunction() &#123; console.log(this);&#125;new logFunction(); //logs logFunction &#123;&#125; 当在严格模式(strict mode)中调用函数时，上下文默认是undefined。 执行环境为了解决掉我们从上面学习中会出现的各种困惑，“执行环境(context)”这个词中的“环境(context)”指的是作用域而并非上下文。这是一个怪异的命名规定，但由于JavaScript的文档如此，我们也只好这样约定。 JavaScript是一种单线程语言，所以它同一时间只能执行单个任务。其他任务排列在执行环境中。当JavaScript解析器开始执行你的代码，环境（作用域）默认为全局。全局环境添加到你的执行环境中，事实上这是执行环境里的第一个环境。 之后，每个函数调用都会添加它的环境到执行环境中，无论是函数内部还是其他地方调用函数，都会是相同的过程。 每个函数都会创建它自己的执行环境。 当浏览器执行完环境中的代码，这个环境会从执行环境中弹出，执行环境中当前环境的状态会转移到父级环境。浏览器总是先执行在执行栈顶的执行环境（事实上就是你代码最里面的作用域）。 全局环境只能有一个，函数环境可以有任意多个。执行环境有两个阶段：创建和执行。 创建阶段第一阶段是创建阶段，是函数刚被调用但代码并未执行的时候。创建阶段只要发生了3件事。 创建变量对象 创建作用域链 设置上下文(this)的值 变量对象变量对象(Variable Object)也称为活动对象(activation object)，包含所有变量、函数和其他执行环境中定义的声明。当函数调用时，解析器扫描所有资源，包括函数参数、变量和其他声明。当所有东西填进一个对象，这个对象就是变量对象。 123'variableObject': &#123; //contains function arguments,inner variable and function declarations&#125; 作用域链在执行环境创建阶段，作用域链在变量对象之后创建。作用域链包含变量对象。作用域链用于解析变量。当解析一个变量时，JavaScript开始从最内层沿着父级寻找所需的变量或其他资源。作用域链包含自己执行环境以及所有父级环境中包含的变量对象。 123'scopeChain': &#123; //contains its own variable object and other variable objects of the parent execution contexts&#125; 执行环境对象执行环境可以用下面抽象对象表示: 12345executionContextObject = &#123; 'scopeChain': &#123;&#125;, //contains its own variableObject and other variableObject of the parent execution contexts 'variableObject': &#123;&#125;, //contains function arguments,inner variable and function declarations 'this': valueOfThis&#125; 代码执行阶段执行环境的第二个阶段就是代码执行阶段，进行其他赋值操作并且代码最终被执行 词法作用域 词法作用域的意思是在函数嵌套中，内层函数可以访问父级作用域的变量等资源。这意味着子函数词法绑定到了父级执行环境。词法作用域有事和静态作用域有关。 12345678910111213function grandfather() &#123; var name = 'Hammad'; //likes is not accessible here function parent() &#123; //name is accessible here //likes is not accessible here function child() &#123; //innermost level of the scope chain //name is also accessible here var likes = 'Coding'; &#125; &#125;&#125; 你可能注意到了词法作用域是向前的，意思是子执行环境可以访问name。但不是由父级向后的。意味着父级不能访问likes。这也告诉我们，在不同执行环境中同名变量优先级在执行栈由上到下增加。一个变量和另一个变量同名，内层函数（执行栈顶的环境）有更高的优先级。 闭包 闭包的概念和我们刚学习的词法作用域紧密相关。当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包。闭包包括它们自己的作用域链、父级作用域链和全局作用域链。 闭包不仅能访问外部函数的变量，也能访问外部函数的参数。 即使函数已经return，闭包仍然能访问外部函数的变量。这意味着return的函数允许持续访问外部函数的所有资源。 当你的外部函数return一个内部函数，调用外部函数时return的函数并不会被调用。你必须先用一个单独的变量保存外部函数的调用，完后将这个变量当做函数来调用。看下面这个例子： 123456789101112131415function greet() &#123; name = 'Hammad'; return function() &#123; console.log('Hi' + name); &#125;&#125;greet(); //nothing happends,no errors//the returned function from greet() gets saved in greetLettergreetLetter = greet();//calling greetLetter calls the returned function from the greet() funcitongreetLetter(); //logs 'Hi Hammad' 值得注意的是，即使在greet()函数return后，greetLetter函数扔可以访问greet函数的name变量。如果不使用变量赋值来调用greet函数return的函数，一种方式是使用()两次()()，如下所示： 12345678funciton greet() &#123; name = 'Hammad'; return fucntion() &#123; console.log('Hi' + name); &#125;&#125;greet()(); //logs 'Hi Hammad' 共有作用域和私有作用域 在许多其他编程语言中，你可以通过public、private和protected作用域来设置类中变量和方法的可见性。看下面这个PHP的例子 12345678910111213141516//Public Scopepublic $property;public function method() &#123; // ...&#125;//Private Scopeprivate $property;private fucntion method() &#123; // ...&#125;//Protected Scopeprotected function method() &#123; // ...&#125; 将函数从公有（全局）作用域中封装，使它们免受攻击。但在JavaScript中，没有共有作用域和私有作用域。然而我们可以用闭包实现这一特性。为了使每个函数从全局中分离出去，我们要将它们封装进如下所示的函数中： 123(funcito() &#123; //private scope&#125;)(); 函数结尾的括号告诉解析器立即执行此函数。我们可以在其中加入变量和函数，外部无法访问。但如果我们想在外部访问它们，也就是说我们希望它们一部分是公开的，一部分是私有的。我们可以使用闭包的一种形式，称为模块模式(Module Pattern)，它允许我们用一个对象中的公有作用域和私有作用域来划分函数。 模块模式模块模式如下所示： 1234567891011var Module = (function() &#123; function privateMethod() &#123; //do something &#125; return &#123; publicMethod: function() &#123; //can call privateMethod(); &#125; &#125;&#125;)(); Module的return语句包含了我们的公共函数。私有函数并没有被return。函数没有被return确保了它们在Module命名空间无法访问。但我们的共有函数可以访问我们的私有函数，方便它们使用有用的函数、AJAX调用或其他东西。 12Modele.publicMethod(); //worksModule.privateMethod(); //Uncaught ReferenceError: peivateMathod is not defined 一种习惯是以下划线作为开始命名私有函数，并返回包含共有函数的匿名对象。这使它们在很长的对象中很容易被管理。像下面这样： 1234567891011var Module = (function() &#123; function _privateMethod() &#123; //do something &#125; fucntion publicMethod() &#123; //do something &#125; return &#123; publicMethod: publicMethod &#125;&#125;)(); 立即执行函数表达式（IIFE）另一种形式的闭包是立即执行函数表达式（Immediately-Invoked Function Expression,IIFE）。这是一种在window上下文中自调用的匿名函数，也就是说this的值是window。它暴露了一个单一全局接口用来交互。如下所示： 123(function(window) &#123; //do anything&#125;)(this); 使用.call()，.apply()和.bing()改变上下文 Call和Apply函数来改变函数调用时的上下文。这带给你神奇的编程能力（和统治世界的能力）。你只需要使用call和apply函数并把上下文当做第一个参数传入，而不是使用括号来调用函数。函数自己的参数可以在上下文后面传入。 1234567function hello() &#123; //do something &#125;hello(); //the way you usually call ithello.call(context); //here you can pass the context(value if this) as the first argumenthello.apply(context); //here you can pass the context(value of this) as the first augument .call()和.apply()的区别是Call中其他参数用逗号分隔传入，而Apply允许你传入一个参数数组。 12345678910111213141516function introduce(name, interest) &#123; console.log("Hi! I'm " + name + "and I like " + interest + "."); console.log('The value of this is ' + this + '.');&#125;introduce('Hammad', 'Coding'); //the way you usually call itintroduce.call(window, 'Batman', 'to save Gotham'); //pass the arguments one by one the after the contextintroduce,apply('Hi', ['Bruce Wayne', 'businesses']); //pass the arguments in an array after the context//Output//Hi!I'm Hammad and I like Coding.//The value of this is [object Window].//Hi!I'm Batman and I like to save Gotham.//The value of this is [object Window].//Hi!I'm bruce Wayne and I like businesses.//The value of this is Hi. Call比Apply的效率高一些。 下面这个例子列举文档中所有项目，然后依次在控制台打印出来。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html land="en"&gt; &lt;head&gt; &lt;mata charset="UTF-8"&gt; &lt;title&gt;Things to learn&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Things to Learn to Rule the World&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Learn PHP&lt;/li&gt; &lt;li&gt;Learn Laravel&lt;/li&gt; &lt;li&gt;Learn JavaScript&lt;/li&gt; &lt;li&gt;Learn VueJS&lt;/li&gt; &lt;li&gt;Learn CLI&lt;/li&gt; &lt;li&gt;Learn Git&lt;/li&gt; &lt;li&gt;Learn Astral Paojection&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //Saves a NodeList of all list items on the page in listItems var listItems = document.querySelectorAll('ul li'); //Loops through each of the Node in the listItems Nodelist and logs its content for(var i = 0;i &lt; listItems.length;i ++) &#123; (function() &#123; console.log(this.innerHTML); &#125;).call(listItems[i]); &#125; //Output logs: //Learn PHP //Learn Laravel //Learn JavaScript //Learn VueJS //Learn CLI //Learn Git //Learn Astral Projection &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; HTML文档中仅包含一个无序列表。JavaScript从DOM中选取它们。列表项会被从头到尾循环一遍。在循环时，我们把列表项的内容输出到控制台。 输出语句包含在由括号包裹的函数中，然后调用call函数。相应的列表项传入call函数，确保控制台输出正确对象的innerHTML。 对象可以有方法，同样函数对象也可以有方法。事实上，JavaScript函数有4个内置方法： Function.prototype.apply() Function.prototype.bind() (Introduced in ECMAScript5(ES5)) Function.prototype.call() Function.prototype.tuString() Function.prototype.toString()返回函数代码的字符串表示。 到现在为止，我们讨论了.call()、apply()和toString()。与Call和Apply不同，Bind并不是自己调用函数，它只是在函数调用之前绑定上下文和其他函数。在上面提到的例子中使用Bind： 12345678(function introduce(name, interest) &#123; console.log("Hi! I'm " + name + "and I like " + interest + "."); console.log('The value of this is ' + this + '.');&#125;).bind(window, 'Hammad', 'Cosmology')();//logs://Hi!I'm Hammad and I like Cosmology.//The value of this is [object Window]. Bind像call函数一样用逗号分隔其他传入参数，不像apply那样用数组传入参数。 结论这些概念是JavaScript的基础，如果你想钻研更深的话，理解这些很重要。我希望你对JavaScript作用域及相关概念有了更好的理解。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>